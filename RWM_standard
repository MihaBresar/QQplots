# -*- coding: utf-8 -*-
"""
Created on Fri Mar 21 12:22:59 2025

@author: u2171939
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import probplot

# ----- Random Walk Metropolis (RWM) sampler ----- #
def rwm_sampler(target_density, proposal_std, x0, n_samples):
    """
    Runs the RWM sampler.
    
    Parameters:
        target_density: function
            A function computing the (unnormalized) density of the target.
        proposal_std: float
            Standard deviation of the Normal proposal.
        x0: float
            Starting point.
        n_samples: int
            Total number of samples.
    
    Returns:
        samples: numpy.ndarray
            Array of samples from the target distribution.
    """
    samples = np.zeros(n_samples)
    x = x0
    samples[0] = x
    for i in range(1, n_samples):
        # Propose a new candidate from N(x, proposal_std^2)
        proposal = np.random.normal(loc=x, scale=proposal_std)
        # Acceptance probability
        acceptance_prob = min(1, target_density(proposal) / target_density(x))
        if np.random.rand() < acceptance_prob:
            x = proposal
        samples[i] = x
    return samples

# ----- Target density: Standard Cauchy ----- #
def cauchy_density(x):
    """Standard Cauchy density: f(x)= 1/(pi*(1+x^2))."""
    return 1.0 / (np.pi * (1 + x**3))

# ----- Main simulation parameters ----- #
n_samples = 5000000      # total number of samples
burn_in = 50000         # burn-in period to discard
proposal_std = 1.0      # standard deviation of the proposal distribution
x0 = 0.0                # initial value

# ----- Generate samples using RWM ----- #
samples = rwm_sampler(cauchy_density, proposal_std, x0, n_samples)
samples = samples[burn_in:]  # discard burn-in

# ----- Compute g(x) = |x|^(1/2) and estimate its expectation ----- #
# Here, we estimate π(|x|^(1/2)) = E[|x|^(1/2)] via the sample average.
g_vals = np.sqrt(np.abs(samples))
g_mean = np.mean(g_vals)

# ----- Center the function values ----- #
g_centered = g_vals - g_mean  # this is |x|^(1/2) - π(|x|^(1/2))

# ----- Create block averages to study the CLT behavior ----- #
n_blocks = 100
block_size = len(g_centered) // n_blocks
block_averages = np.array([
    np.mean(g_centered[i * block_size:(i + 1) * block_size])
    for i in range(n_blocks)
])

# ----- Generate QQ plot for the block averages ----- #
plt.figure(figsize=(6, 6))
probplot(block_averages, dist="norm", plot=plt)
plt.title("QQ Plot of Block Averages\nof g(x) = |x|^(1/2) - E[|x|^(1/2)] for RWM")
plt.xlabel("Theoretical Quantiles")
plt.ylabel("Sample Quantiles")
plt.show()
